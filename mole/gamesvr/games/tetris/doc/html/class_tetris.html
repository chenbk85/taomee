<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Tetris: Tetris类参考</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- 制作者 Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>首页</span></a></li>
      <li class="current"><a href="classes.html"><span>类</span></a></li>
      <li><a href="files.html"><span>文件</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>按字典顺序排序的列表</span></a></li>
      <li><a href="annotated.html"><span>组合类型列表</span></a></li>
      <li><a href="functions.html"><span>组合类型成员</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Tetris类参考</h1><!-- doxytag: class="Tetris" -->实现俄罗斯方块服务端。 上层已经初始化了游戏组结构体，玩家结构体; 类内部可以添加超时处理函数； 类内部处理上层传递过来的协议级消息；  
<a href="#_details">更多...</a>
<p>
<div class="dynheader">
Tetris合作图：</div>
<div class="dynsection">
<p><center><img src="class_tetris__coll__graph.png" border="0" usemap="#_tetris__coll__map" alt="Collaboration graph"></center>
<map name="_tetris__coll__map">
<area shape="rect" href="struct_tetris_1_1____suser__session.html" title="{Tetris::__suser_session\n|+ session_id\l+ user_id\l|}" alt="" coords="19,5,179,101"></map>
<center><font size="2">[<a href="graph_legend.html">图例</a>]</font></center></div>

<p>
<a href="class_tetris-members.html">所有成员的列表。</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>公有成员</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#608fac99678c4b6e717b2ef09967fcbf">destroy</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">提供给上层调用的三个接口函数之一。游戏结束时清理资源  <a href="#608fac99678c4b6e717b2ef09967fcbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#6c4ec914098940b6d373a20d8203108c">handle_data</a> (sprite_t *player, int cmd, const uint8_t body[], int body_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">提供给上层调用的三个接口函数之一。上层通知本模块处理相关事件的接口  <a href="#6c4ec914098940b6d373a20d8203108c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#36fa0cbee5475b1e3451e183dbf71388">handle_timeout</a> (void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">处理用户游戏超时，处理方式，直接结束用户的游戏  <a href="#36fa0cbee5475b1e3451e183dbf71388"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#735b3d1ba1fc861c73804809fc8edcfd">init</a> (sprite_t *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">提供给上层调用的三个接口函数之一. 以初始化游戏数据  <a href="#735b3d1ba1fc861c73804809fc8edcfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#a0e3af7ecd75d42ea2ce0a518ca786cb">Tetris</a> (game_group_t *grp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">构造函数，需要用一个game_group_t结构体指针初始化  <a href="#a0e3af7ecd75d42ea2ce0a518ca786cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#83428bf8cd94dc29673d5f0160718818">~Tetris</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">析构函数  <a href="#83428bf8cd94dc29673d5f0160718818"></a><br></td></tr>
<tr><td colspan="2"><br><h2>私有类型</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#435b20b884815365e545b6c6173b1397">__escore_factor</a> { <a class="el" href="class_tetris.html#435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c">escore_normal</a> =  0, 
<a class="el" href="class_tetris.html#435b20b884815365e545b6c6173b139720dae0984b1b909e1a900612939d82e0">escore_timeout</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5">__etetris_cmd_id</a> { <a class="el" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5bce668a76f25e2faa5f25b72751da31a">etetris_game_new_bout</a> =  32000, 
<a class="el" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5937bf10419f19636c7054b7dd7eeadd7">etetris_trans_data</a> =  32001, 
<a class="el" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae505f4df4aa6b266f26c6deaa92d3dc5e6">etetris_game_end_bout</a> =  32002
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef enum <br>
<a class="el" href="class_tetris.html#435b20b884815365e545b6c6173b1397">Tetris::__escore_factor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#43f834d9c36955c58bcf10462cb77526">escore_factor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef enum <br>
<a class="el" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5">Tetris::__etetris_cmd_id</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#f9860f145386de347b65557ce684d0ff">etetris_cmd_id</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <br>
<a class="el" href="struct_tetris_1_1____suser__session.html">Tetris::__suser_session</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#c66bb1be1bf916353982547a410efec1">suser_session</a></td></tr>

<tr><td colspan="2"><br><h2>私有成员</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#59368708fed1ffec042a43b3b6fe75d9">calc_default_score</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">其它情况时，计算分数  <a href="#59368708fed1ffec042a43b3b6fe75d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#32348d677ce788e541bf64d5e267ddc9">calc_normal_score</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">正常玩完游戏,分出胜负，计算分数  <a href="#32348d677ce788e541bf64d5e267ddc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#ff52b80e9f58d13ba38084c7aa0aa366">calc_timeout_score</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">游戏超时，未分出胜负，计算分数  <a href="#ff52b80e9f58d13ba38084c7aa0aa366"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#eb2ef9f36063b968d47fc2037d7be64f">calculate_score</a> (<a class="el" href="class_tetris.html#43f834d9c36955c58bcf10462cb77526">escore_factor</a> efactor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">游戏完毕，根据情形因子计算各类玩家获得的分数, 此处玩家分为赢家和输家， 可以括展平手， 看家等  <a href="#eb2ef9f36063b968d47fc2037d7be64f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#b9a2bfc4ad219d1e0788aace91f88fbd">check_player_session</a> (sprite_t *player, const uint8_t body[], int body_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">检验用户此次的session号是否合法，并更新记录的session号，以用于下次检验  <a href="#b9a2bfc4ad219d1e0788aace91f88fbd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#dabda5ae72fe3e51b6e7f31bd990a5f3">distribute_score</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">给用户分发分数  <a href="#dabda5ae72fe3e51b6e7f31bd990a5f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#665ee31f1ead3dda47a0ed27ffa3861c">game_player_leave</a> (sprite_t *player, const uint8_t body[], int body_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">玩家离开了游戏，要清理本地资源  <a href="#665ee31f1ead3dda47a0ed27ffa3861c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#8d1b3c45f6d50a252bcac287acc46df2">get_client_submit_result</a> (sprite_t *player, const uint8_t body[], int body_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">解析玩家提交上来的游戏结果，分数  <a href="#8d1b3c45f6d50a252bcac287acc46df2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#8646c4e87b3836630a606ae90841aa62">notify_player_game_ready</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">通知加入本游戏的玩家，所有游戏成员都准备好了，可以开始游戏  <a href="#8646c4e87b3836630a606ae90841aa62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="188ee94012b3d7959abe057e288673be"></a><!-- doxytag: member="Tetris::notify_player_win" ref="188ee94012b3d7959abe057e288673be" args="(sprite_t *winner_player)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>notify_player_win</b> (sprite_t *winner_player)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#2eefabad6f82beb5a9f9d1173e40fccb">tetris_end_bout</a> (sprite_t *player, const uint8_t body[], int body_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">游戏结束了，记录用户提交上来的数据（输赢，分数）  <a href="#2eefabad6f82beb5a9f9d1173e40fccb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#99395dc5f1271c77236fc967687de13c">tetris_new_bout</a> (sprite_t *plyaer, const uint8_t body[], int body_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">开始游戏, 当进入游戏的玩家满了后，通知所有人可以开始玩了  <a href="#99395dc5f1271c77236fc967687de13c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#7562e7124f22612d3c482e8d1438d773">tetris_trans_data</a> (sprite_t *player, const uint8_t body[], int body_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">游戏过程中一个游戏用户提交了数据，要转发通知到其它各个用户  <a href="#7562e7124f22612d3c482e8d1438d773"></a><br></td></tr>
<tr><td colspan="2"><br><h2>私有属性</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4f3fe18bb316aa918d35d90a79addad6"></a><!-- doxytag: member="Tetris::bhas_end_game" ref="4f3fe18bb316aa918d35d90a79addad6" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>bhas_end_game</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89728a478403846a2af3f73fa11460c7"></a><!-- doxytag: member="Tetris::bready_to_transdata" ref="89728a478403846a2af3f73fa11460c7" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#89728a478403846a2af3f73fa11460c7">bready_to_transdata</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">判断玩家是否都准备好了可以接收转发数据 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e362aa8bac35612cb28703f60b85043"></a><!-- doxytag: member="Tetris::game_group_" ref="9e362aa8bac35612cb28703f60b85043" args="" -->
game_group_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043">game_group_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">构造函数参数中记录的游戏组指针 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3500653d2368ba3c3929af471366ac11"></a><!-- doxytag: member="Tetris::game_score_" ref="3500653d2368ba3c3929af471366ac11" args="[2]" -->
game_score_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#3500653d2368ba3c3929af471366ac11">game_score_</a> [2]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">分数的种类, 目前两种：赢家，输家, 看客不给分数 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25904f55bc4f8a3376302c06e494dfa7"></a><!-- doxytag: member="Tetris::game_sessions_" ref="25904f55bc4f8a3376302c06e494dfa7" args="[2]" -->
<a class="el" href="struct_tetris_1_1____suser__session.html">suser_session</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7">game_sessions_</a> [2]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">记录游戏玩家每次的session号 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8756ef393f0c4aa6b455d5aba52dd7e"></a><!-- doxytag: member="Tetris::uiplayer_ready_count" ref="e8756ef393f0c4aa6b455d5aba52dd7e" args="" -->
uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>uiplayer_ready_count</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3fb3cdef363f87fc48ca2f665f678b0"></a><!-- doxytag: member="Tetris::winning_player_pos_" ref="f3fb3cdef363f87fc48ca2f665f678b0" args="" -->
uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetris.html#f3fb3cdef363f87fc48ca2f665f678b0">winning_player_pos_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">赢家的pos_id <br></td></tr>
<tr><td colspan="2"><br><h2>组合类型</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tetris_1_1____suser__session.html">__suser_session</a></td></tr>

</table>
<hr><a name="_details"></a><h2>详细描述</h2>
实现俄罗斯方块服务端。 上层已经初始化了游戏组结构体，玩家结构体; 类内部可以添加超时处理函数； 类内部处理上层传递过来的协议级消息； <hr><h2>成员类型定义文档</h2>
<a class="anchor" name="43f834d9c36955c58bcf10462cb77526"></a><!-- doxytag: member="Tetris::escore_factor" ref="43f834d9c36955c58bcf10462cb77526" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="class_tetris.html#435b20b884815365e545b6c6173b1397">Tetris::__escore_factor</a> <a class="el" href="class_tetris.html#43f834d9c36955c58bcf10462cb77526">Tetris::escore_factor</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
为计算分数定义的枚举类型 
</div>
</div><p>
<a class="anchor" name="f9860f145386de347b65557ce684d0ff"></a><!-- doxytag: member="Tetris::etetris_cmd_id" ref="f9860f145386de347b65557ce684d0ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5">Tetris::__etetris_cmd_id</a> <a class="el" href="class_tetris.html#f9860f145386de347b65557ce684d0ff">Tetris::etetris_cmd_id</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
为协议消息定义的枚举类型 
</div>
</div><p>
<a class="anchor" name="c66bb1be1bf916353982547a410efec1"></a><!-- doxytag: member="Tetris::suser_session" ref="c66bb1be1bf916353982547a410efec1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_tetris_1_1____suser__session.html">Tetris::__suser_session</a> <a class="el" href="struct_tetris_1_1____suser__session.html">Tetris::suser_session</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
为记录每个用户的session信息定义的结构体 
</div>
</div><p>
<hr><h2>成员枚举类型文档</h2>
<a class="anchor" name="435b20b884815365e545b6c6173b1397"></a><!-- doxytag: member="Tetris::__escore_factor" ref="435b20b884815365e545b6c6173b1397" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_tetris.html#435b20b884815365e545b6c6173b1397">Tetris::__escore_factor</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
为计算分数定义的枚举类型 <dl compact><dt><b>枚举值: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c"></a><!-- doxytag: member="escore_normal" ref="435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c" args="" -->escore_normal</em>&nbsp;</td><td>
正常玩完游戏，分出胜负 </td></tr>
<tr><td valign="top"><em><a class="anchor" name="435b20b884815365e545b6c6173b139720dae0984b1b909e1a900612939d82e0"></a><!-- doxytag: member="escore_timeout" ref="435b20b884815365e545b6c6173b139720dae0984b1b909e1a900612939d82e0" args="" -->escore_timeout</em>&nbsp;</td><td>
超时，没有分出胜负 </td></tr>
</table>
</dl>
<div class="fragment"><pre class="fragment"><a name="l00054"></a>00054                                      {
<a name="l00055"></a>00055              <a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c" title="正常玩完游戏，分出胜负">escore_normal</a> = 0, 
<a name="l00056"></a>00056              <a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139720dae0984b1b909e1a900612939d82e0" title="超时，没有分出胜负">escore_timeout</a> 
<a name="l00057"></a>00057          }<a class="code" href="class_tetris.html#43f834d9c36955c58bcf10462cb77526">escore_factor</a>;
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5a35ce2e4e0573e2f78a24071131fae5"></a><!-- doxytag: member="Tetris::__etetris_cmd_id" ref="5a35ce2e4e0573e2f78a24071131fae5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5">Tetris::__etetris_cmd_id</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
为协议消息定义的枚举类型 <dl compact><dt><b>枚举值: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="5a35ce2e4e0573e2f78a24071131fae5bce668a76f25e2faa5f25b72751da31a"></a><!-- doxytag: member="etetris_game_new_bout" ref="5a35ce2e4e0573e2f78a24071131fae5bce668a76f25e2faa5f25b72751da31a" args="" -->etetris_game_new_bout</em>&nbsp;</td><td>
一个用户请求开始俄罗斯方块游戏 </td></tr>
<tr><td valign="top"><em><a class="anchor" name="5a35ce2e4e0573e2f78a24071131fae5937bf10419f19636c7054b7dd7eeadd7"></a><!-- doxytag: member="etetris_trans_data" ref="5a35ce2e4e0573e2f78a24071131fae5937bf10419f19636c7054b7dd7eeadd7" args="" -->etetris_trans_data</em>&nbsp;</td><td>
用户请求转发数据 </td></tr>
<tr><td valign="top"><em><a class="anchor" name="5a35ce2e4e0573e2f78a24071131fae505f4df4aa6b266f26c6deaa92d3dc5e6"></a><!-- doxytag: member="etetris_game_end_bout" ref="5a35ce2e4e0573e2f78a24071131fae505f4df4aa6b266f26c6deaa92d3dc5e6" args="" -->etetris_game_end_bout</em>&nbsp;</td><td>
用户发送过来的俄罗斯方块游戏结束 </td></tr>
</table>
</dl>
<div class="fragment"><pre class="fragment"><a name="l00047"></a>00047                                       {
<a name="l00048"></a>00048              <a class="code" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5bce668a76f25e2faa5f25b72751da31a" title="一个用户请求开始俄罗斯方块游戏">etetris_game_new_bout</a> = 32000, 
<a name="l00049"></a>00049              <a class="code" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5937bf10419f19636c7054b7dd7eeadd7" title="用户请求转发数据">etetris_trans_data</a>    = 32001, 
<a name="l00050"></a>00050              <a class="code" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae505f4df4aa6b266f26c6deaa92d3dc5e6" title="用户发送过来的俄罗斯方块游戏结束">etetris_game_end_bout</a> = 32002 
<a name="l00051"></a>00051          }<a class="code" href="class_tetris.html#f9860f145386de347b65557ce684d0ff">etetris_cmd_id</a>;
</pre></div>
<p>

</div>
</div><p>
<hr><h2>构造及析构函数文档</h2>
<a class="anchor" name="a0e3af7ecd75d42ea2ce0a518ca786cb"></a><!-- doxytag: member="Tetris::Tetris" ref="a0e3af7ecd75d42ea2ce0a518ca786cb" args="(game_group_t *grp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tetris::Tetris           </td>
          <td>(</td>
          <td class="paramtype">game_group_t *&nbsp;</td>
          <td class="paramname"> <em>grp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
构造函数，需要用一个game_group_t结构体指针初始化 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>game_group_t*</em>&nbsp;</td><td>grp, 游戏组结构体指针 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>None </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00035"></a>00035 { 
<a name="l00036"></a>00036     <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a> = grp; 
<a name="l00037"></a>00037     DEBUG_LOG(<span class="stringliteral">"%s: TETRIS CONSTRUCTOR!"</span>,<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;name);
<a name="l00038"></a>00038 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="83428bf8cd94dc29673d5f0160718818"></a><!-- doxytag: member="Tetris::~Tetris" ref="83428bf8cd94dc29673d5f0160718818" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tetris::~Tetris           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
析构函数 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>None </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00046"></a>00046 { 
<a name="l00047"></a>00047     DEBUG_LOG(<span class="stringliteral">"%s: TETRIS DESTRUCTOR!"</span>,<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;name);
<a name="l00048"></a>00048 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>成员函数文档</h2>
<a class="anchor" name="59368708fed1ffec042a43b3b6fe75d9"></a><!-- doxytag: member="Tetris::calc_default_score" ref="59368708fed1ffec042a43b3b6fe75d9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tetris::calc_default_score           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
其它情况时，计算分数 
<p>
游戏默认的（其它的）方式计算各类玩家的分数<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>void</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00572"></a>00572 {
<a name="l00573"></a>00573     <span class="comment">//0 下标存的是赢家获得分数， 1下标存的是输家获得分数，</span>
<a name="l00574"></a>00574 
<a name="l00575"></a>00575     <span class="comment">//大家分数概率上相同</span>
<a name="l00576"></a>00576     <a class="code" href="class_tetris.html#32348d677ce788e541bf64d5e267ddc9" title="正常玩完游戏,分出胜负，计算分数">calc_normal_score</a>();
<a name="l00577"></a>00577 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="32348d677ce788e541bf64d5e267ddc9"></a><!-- doxytag: member="Tetris::calc_normal_score" ref="32348d677ce788e541bf64d5e267ddc9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tetris::calc_normal_score           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
正常玩完游戏,分出胜负，计算分数 
<p>
游戏正常结束计算各类玩家的分数<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>void</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00494"></a>00494 {
<a name="l00495"></a>00495     <span class="comment">//0 下标存的是赢家获得分数， 1下标存的是输家获得分数，</span>
<a name="l00496"></a>00496     
<a name="l00497"></a>00497     <span class="comment">//赢家是输家 分数的 2 倍</span>
<a name="l00498"></a>00498     <span class="comment">//可优化，玩的时间越长分数越高</span>
<a name="l00499"></a>00499     <span class="comment">//以及算上其它个人属性</span>
<a name="l00500"></a>00500     <span class="comment">//find the winner</span>
<a name="l00501"></a>00501     <span class="keywordflow">if</span>((get_now_tv()-&gt;tv_sec - <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;start) &lt; 30)
<a name="l00502"></a>00502     {
<a name="l00503"></a>00503         memset(<a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>, 0, <span class="keyword">sizeof</span>(game_score_t)*2);
<a name="l00504"></a>00504         <span class="keywordflow">return</span>;
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506     <span class="keywordtype">int</span> index = 0;
<a name="l00507"></a>00507     int32_t loster_score = 0;
<a name="l00508"></a>00508     int32_t winner_score = 0;
<a name="l00509"></a>00509     <span class="keywordflow">for</span>(index = 0; index &lt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count; ++index)
<a name="l00510"></a>00510     {
<a name="l00511"></a>00511         sprite_t* tmp_player = <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[index];
<a name="l00512"></a>00512         <span class="keywordflow">if</span>(tmp_player-&gt;pos_id == <a class="code" href="class_tetris.html#f3fb3cdef363f87fc48ca2f665f678b0" title="赢家的pos_id">winning_player_pos_</a>)
<a name="l00513"></a>00513         {
<a name="l00514"></a>00514             winner_score = tmp_player-&gt;score;
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516         <span class="keywordflow">else</span>
<a name="l00517"></a>00517         {
<a name="l00518"></a>00518             loster_score = tmp_player-&gt;score;
<a name="l00519"></a>00519         }
<a name="l00520"></a>00520     }
<a name="l00521"></a>00521     <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count == 1)
<a name="l00522"></a>00522     {
<a name="l00523"></a>00523         winner_score = winner_score &gt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;score ? <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;score : winner_score;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525         <span class="keywordtype">float</span> percent = (float)winner_score / (<span class="keywordtype">float</span>)<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;score;
<a name="l00526"></a>00526         <span class="keywordflow">if</span>(percent &lt; 0.02) percent = 0.02;
<a name="l00527"></a>00527 
<a name="l00528"></a>00528         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].score  = winner_score;
<a name="l00529"></a>00529         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].coins  = (int)(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;yxb * percent);
<a name="l00530"></a>00530         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].exp    = (int)(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;exp * percent) ;
<a name="l00531"></a>00531         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].lovely = (int)(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;lovely * percent);
<a name="l00532"></a>00532     }
<a name="l00533"></a>00533     <span class="keywordflow">else</span>
<a name="l00534"></a>00534     {
<a name="l00535"></a>00535         winner_score = winner_score &gt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;score?<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;score:winner_score;
<a name="l00536"></a>00536 
<a name="l00537"></a>00537         <span class="keywordtype">float</span> percent = (float)(get_now_tv()-&gt;tv_sec - <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;start) / (<span class="keywordtype">float</span>)<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;timeout;
<a name="l00538"></a>00538         <span class="keywordflow">if</span>(percent &lt; 0.02) percent = 0.02;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].score  = winner_score;
<a name="l00541"></a>00541         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].coins  = (int)(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;yxb * percent);
<a name="l00542"></a>00542         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].exp    = (int)(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;exp * percent) ;
<a name="l00543"></a>00543         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].lovely = (int)(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;lovely * percent);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[1].score = loster_score;
<a name="l00546"></a>00546         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[1].coins  = <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].coins/2; 
<a name="l00547"></a>00547         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[1].exp    = <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].exp/2;
<a name="l00548"></a>00548         <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[1].lovely = <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].lovely/2;
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ff52b80e9f58d13ba38084c7aa0aa366"></a><!-- doxytag: member="Tetris::calc_timeout_score" ref="ff52b80e9f58d13ba38084c7aa0aa366" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tetris::calc_timeout_score           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
游戏超时，未分出胜负，计算分数 
<p>
游戏超时计算各类玩家的分数<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>void</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00559"></a>00559 {
<a name="l00560"></a>00560     <span class="comment">//0 下标存的是赢家获得分数， 1下标存的是输家获得分数，</span>
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     <span class="comment">//大家可能获得相同分数，但概率上先入游戏的分数高些</span>
<a name="l00563"></a>00563     <a class="code" href="class_tetris.html#32348d677ce788e541bf64d5e267ddc9" title="正常玩完游戏,分出胜负，计算分数">calc_normal_score</a>();
<a name="l00564"></a>00564 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="eb2ef9f36063b968d47fc2037d7be64f"></a><!-- doxytag: member="Tetris::calculate_score" ref="eb2ef9f36063b968d47fc2037d7be64f" args="(escore_factor efactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tetris::calculate_score           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tetris.html#43f834d9c36955c58bcf10462cb77526">escore_factor</a>&nbsp;</td>
          <td class="paramname"> <em>efactor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
游戏完毕，根据情形因子计算各类玩家获得的分数, 此处玩家分为赢家和输家， 可以括展平手， 看家等 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>escore_factor</em>&nbsp;</td><td>efactor, 计算分数时用的因子 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00472"></a>00472 {
<a name="l00473"></a>00473     <span class="comment">//策划安给的分数计算方式过于简单，目前下面个种方式都是一样的算法:w</span>
<a name="l00474"></a>00474     <span class="keywordflow">switch</span>(efactor)
<a name="l00475"></a>00475     {
<a name="l00476"></a>00476     <span class="keywordflow">case</span> <a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c" title="正常玩完游戏，分出胜负">escore_normal</a>:
<a name="l00477"></a>00477         <a class="code" href="class_tetris.html#32348d677ce788e541bf64d5e267ddc9" title="正常玩完游戏,分出胜负，计算分数">calc_normal_score</a>();
<a name="l00478"></a>00478         <span class="keywordflow">break</span>;
<a name="l00479"></a>00479     <span class="keywordflow">case</span> <a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139720dae0984b1b909e1a900612939d82e0" title="超时，没有分出胜负">escore_timeout</a>:
<a name="l00480"></a>00480         <a class="code" href="class_tetris.html#ff52b80e9f58d13ba38084c7aa0aa366" title="游戏超时，未分出胜负，计算分数">calc_timeout_score</a>();
<a name="l00481"></a>00481         <span class="keywordflow">break</span>;
<a name="l00482"></a>00482     <span class="keywordflow">default</span>:
<a name="l00483"></a>00483         <a class="code" href="class_tetris.html#59368708fed1ffec042a43b3b6fe75d9" title="其它情况时，计算分数">calc_default_score</a>();
<a name="l00484"></a>00484         <span class="keywordflow">break</span>;
<a name="l00485"></a>00485     }
<a name="l00486"></a>00486 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b9a2bfc4ad219d1e0788aace91f88fbd"></a><!-- doxytag: member="Tetris::check_player_session" ref="b9a2bfc4ad219d1e0788aace91f88fbd" args="(sprite_t *player, const uint8_t body[], int body_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tetris::check_player_session           </td>
          <td>(</td>
          <td class="paramtype">sprite_t *&nbsp;</td>
          <td class="paramname"> <em>player</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>body</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>body_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
检验用户此次的session号是否合法，并更新记录的session号，以用于下次检验 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite_t*</em>&nbsp;</td><td>player, 用户结构体指针 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>uint8_t body[], 包含sesseion号的数据，网络接收的原始数据 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>body_len, 数据包长度 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>检验的成功与否 true 或 false. </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00386"></a>00386 {
<a name="l00387"></a>00387     <span class="keywordflow">if</span>((uint32_t)body_len &lt; <span class="keyword">sizeof</span>(uint32_t)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00388"></a>00388 
<a name="l00389"></a>00389     uint32_t tmp_session = *((uint32_t*)body);
<a name="l00390"></a>00390     uint32_t local_session = ntohl(tmp_session);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392     <span class="comment">//第一次添加用户session</span>
<a name="l00393"></a>00393     <span class="keywordtype">int</span> session_count = 2 &gt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;players ? <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;players : 2;
<a name="l00394"></a>00394     <span class="keywordtype">int</span> i = 0;
<a name="l00395"></a>00395     <span class="keywordflow">for</span> ( i = 0; i &lt; session_count; i += 1 )
<a name="l00396"></a>00396     {
<a name="l00397"></a>00397         <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7" title="记录游戏玩家每次的session号">game_sessions_</a>[i].user_id == 0)
<a name="l00398"></a>00398        {
<a name="l00399"></a>00399             <a class="code" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7" title="记录游戏玩家每次的session号">game_sessions_</a>[i].<a class="code" href="struct_tetris_1_1____suser__session.html#e2d54028e461fb29b6d605584027b40f" title="次session号所属用户的ID，即其米米号">user_id</a> = player-&gt;id;
<a name="l00400"></a>00400             <a class="code" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7" title="记录游戏玩家每次的session号">game_sessions_</a>[i].<a class="code" href="struct_tetris_1_1____suser__session.html#2696327fe0b78c8e5476b9794b5807be" title="sesseion号">session_id</a> = local_session;
<a name="l00401"></a>00401 <span class="comment">//            DEBUG_LOG("check_player_session(), user [%d] first time check true.", player-&gt;id);</span>
<a name="l00402"></a>00402             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00403"></a>00403         }
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     <span class="comment">//第一次以后就开始检验session</span>
<a name="l00407"></a>00407     <span class="keywordflow">for</span> ( i = 0; i &lt; session_count; i += 1 )
<a name="l00408"></a>00408     {
<a name="l00409"></a>00409         <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7" title="记录游戏玩家每次的session号">game_sessions_</a>[i].user_id == player-&gt;id)
<a name="l00410"></a>00410         {
<a name="l00411"></a>00411             <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7" title="记录游戏玩家每次的session号">game_sessions_</a>[i].session_id == (local_session -1))
<a name="l00412"></a>00412             {
<a name="l00413"></a>00413                 <a class="code" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7" title="记录游戏玩家每次的session号">game_sessions_</a>[i].<a class="code" href="struct_tetris_1_1____suser__session.html#2696327fe0b78c8e5476b9794b5807be" title="sesseion号">session_id</a>++;
<a name="l00414"></a>00414 <span class="comment">//                DEBUG_LOG("check_player_session(), user [%d] check true.", player-&gt;id);</span>
<a name="l00415"></a>00415                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00416"></a>00416             }
<a name="l00417"></a>00417             <span class="keywordflow">else</span>
<a name="l00418"></a>00418             {
<a name="l00419"></a>00419                 DEBUG_LOG(<span class="stringliteral">"TETRIS, check_player_session(), USER [%d] CHECK FALSE."</span>, player-&gt;id);
<a name="l00420"></a>00420                 DEBUG_LOG(<span class="stringliteral">"OLD SESSION [%d], NEW SESSION [%d]."</span>, 
<a name="l00421"></a>00421                         <a class="code" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7" title="记录游戏玩家每次的session号">game_sessions_</a>[0].session_id, local_session);
<a name="l00422"></a>00422                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00423"></a>00423             }
<a name="l00424"></a>00424         }
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426     DEBUG_LOG(<span class="stringliteral">"TETRIS, check_player_session(), USER [%d] CHECK FALSE. NO THIS USER SESSION HISTROY"</span>,
<a name="l00427"></a>00427                 player-&gt;id);
<a name="l00428"></a>00428     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00429"></a>00429 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="608fac99678c4b6e717b2ef09967fcbf"></a><!-- doxytag: member="Tetris::destroy" ref="608fac99678c4b6e717b2ef09967fcbf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tetris::destroy           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
提供给上层调用的三个接口函数之一。游戏结束时清理资源 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>void</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00112"></a>00112 {
<a name="l00113"></a>00113 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dabda5ae72fe3e51b6e7f31bd990a5f3"></a><!-- doxytag: member="Tetris::distribute_score" ref="dabda5ae72fe3e51b6e7f31bd990a5f3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tetris::distribute_score           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
给用户分发分数 
<p>
给玩家分发分数，经验值<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>void</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00585"></a>00585 {
<a name="l00586"></a>00586 <span class="comment">//    DEBUG_LOG("distribute_score(), winner pos id: %d.", winning_player_pos_);</span>
<a name="l00587"></a>00587     <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count &gt; 1)
<a name="l00588"></a>00588     {
<a name="l00589"></a>00589         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count; ++i)
<a name="l00590"></a>00590         {
<a name="l00591"></a>00591             sprite_t* player = <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i];
<a name="l00592"></a>00592             <span class="keywordtype">int</span> score_index = 0;
<a name="l00593"></a>00593 <span class="comment">//            DEBUG_LOG("distribute_score(), player pos id: %d.", player-&gt;pos_id);</span>
<a name="l00594"></a>00594             <span class="keywordflow">if</span>(player-&gt;pos_id == <a class="code" href="class_tetris.html#f3fb3cdef363f87fc48ca2f665f678b0" title="赢家的pos_id">winning_player_pos_</a>)
<a name="l00595"></a>00595             {
<a name="l00596"></a>00596                 score_index = 0;  <span class="comment">//赢家类型</span>
<a name="l00597"></a>00597                 <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[score_index].rank = 1;
<a name="l00598"></a>00598             }
<a name="l00599"></a>00599             <span class="keywordflow">else</span>
<a name="l00600"></a>00600             {
<a name="l00601"></a>00601                 score_index = 1;  <span class="comment">//输家类型</span>
<a name="l00602"></a>00602                 <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[score_index].rank = 2;
<a name="l00603"></a>00603             }
<a name="l00604"></a>00604             pack_score_session(player, &amp;(<a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[score_index]), 34, <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[score_index].score);
<a name="l00605"></a>00605             submit_game_score(player, &amp;(<a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[score_index]));
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608     <span class="keywordflow">else</span>
<a name="l00609"></a>00609     {
<a name="l00610"></a>00610         sprite_t* player = <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[0];
<a name="l00611"></a>00611 <span class="comment">//        DEBUG_LOG("distribute_score(), player id: %d.", player-&gt;id);</span>
<a name="l00612"></a>00612         pack_score_session(player, &amp;(<a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0]), 33, <a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0].score);
<a name="l00613"></a>00613         submit_game_score(player, &amp;(<a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>[0]));
<a name="l00614"></a>00614     }
<a name="l00615"></a>00615 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="665ee31f1ead3dda47a0ed27ffa3861c"></a><!-- doxytag: member="Tetris::game_player_leave" ref="665ee31f1ead3dda47a0ed27ffa3861c" args="(sprite_t *player, const uint8_t body[], int body_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tetris::game_player_leave           </td>
          <td>(</td>
          <td class="paramtype">sprite_t *&nbsp;</td>
          <td class="paramname"> <em>player</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>body</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>body_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
玩家离开了游戏，要清理本地资源 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite_t*</em>&nbsp;</td><td>player, 玩家结构体指针 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>uint8_t body[], 玩家发送来的数据体 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>body_len, 数据体长度 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00166"></a>00166 {
<a name="l00167"></a>00167     assert(player != NULL);
<a name="l00168"></a>00168     assert(body != NULL);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="comment">//  DEBUG_LOG("game_player_leave(), DATA BODY LEN :[%d].", body_len);</span>
<a name="l00171"></a>00171   <span class="comment">//  DEBUG_LOG("THIS TIME PLAYER ID:[%u], GROUP USER COUNT:[%u].", player-&gt;id, game_group_-&gt;count);</span>
<a name="l00172"></a>00172 
<a name="l00173"></a>00173     <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count &gt; 1)
<a name="l00174"></a>00174     {
<a name="l00175"></a>00175         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count; ++i)
<a name="l00176"></a>00176         {
<a name="l00177"></a>00177             <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i]-&gt;id != player-&gt;id)
<a name="l00178"></a>00178             {
<a name="l00179"></a>00179                 <span class="keywordflow">if</span>(!bhas_end_game) 
<a name="l00180"></a>00180                 {
<a name="l00181"></a>00181                     bhas_end_game = <span class="keyword">true</span>;
<a name="l00182"></a>00182                     <a class="code" href="class_tetris.html#f3fb3cdef363f87fc48ca2f665f678b0" title="赢家的pos_id">winning_player_pos_</a> = <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i]-&gt;pos_id;
<a name="l00183"></a>00183                     <a class="code" href="class_tetris.html#eb2ef9f36063b968d47fc2037d7be64f" title="游戏完毕，根据情形因子计算各类玩家获得的分数, 此处玩家分为赢家和输...">calculate_score</a>(<a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c" title="正常玩完游戏，分出胜负">escore_normal</a>);
<a name="l00184"></a>00184                     notify_player_win(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i]);
<a name="l00185"></a>00185                     <a class="code" href="class_tetris.html#dabda5ae72fe3e51b6e7f31bd990a5f3" title="给用户分发分数">distribute_score</a>();
<a name="l00186"></a>00186                 }
<a name="l00187"></a>00187                 <span class="keywordflow">break</span>;
<a name="l00188"></a>00188             }
<a name="l00189"></a>00189         }
<a name="l00190"></a>00190     }
<a name="l00191"></a>00191     <span class="keywordflow">else</span>
<a name="l00192"></a>00192     {
<a name="l00193"></a>00193         <a class="code" href="class_tetris.html#eb2ef9f36063b968d47fc2037d7be64f" title="游戏完毕，根据情形因子计算各类玩家获得的分数, 此处玩家分为赢家和输...">calculate_score</a>(<a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c" title="正常玩完游戏，分出胜负">escore_normal</a>);
<a name="l00194"></a>00194         notify_player_win(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[0]);
<a name="l00195"></a>00195         <a class="code" href="class_tetris.html#dabda5ae72fe3e51b6e7f31bd990a5f3" title="给用户分发分数">distribute_score</a>();
<a name="l00196"></a>00196     }
<a name="l00197"></a>00197     <span class="keywordflow">return</span> GER_player_offline;
<a name="l00198"></a>00198 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8d1b3c45f6d50a252bcac287acc46df2"></a><!-- doxytag: member="Tetris::get_client_submit_result" ref="8d1b3c45f6d50a252bcac287acc46df2" args="(sprite_t *player, const uint8_t body[], int body_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tetris::get_client_submit_result           </td>
          <td>(</td>
          <td class="paramtype">sprite_t *&nbsp;</td>
          <td class="paramname"> <em>player</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>body</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>body_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
解析玩家提交上来的游戏结果，分数 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite_t*</em>&nbsp;</td><td>player, 玩家结构体指针 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>uint8_t body[], 玩家发送来的数据体 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>body_len, 数据体长度 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>bool类型，数据不够，不可解析返回false, 否则返回true; </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00439"></a>00439 {
<a name="l00440"></a>00440     <span class="keywordflow">if</span>(body_len &lt; 8) 
<a name="l00441"></a>00441     {
<a name="l00442"></a>00442         ERROR_LOG(<span class="stringliteral">"TETRIS, PARSE CLIENT SUBMIT SCORE. PLAYER ID:[%u], DATA BODY LEN = %d."</span>, 
<a name="l00443"></a>00443                   player-&gt;id, body_len);
<a name="l00444"></a>00444         ERROR_LOG(<span class="stringliteral">"TETRIS, PARSE CLIENT SUBMIT SCORE ERROR, BODY LEN WRONG. NEED AT LEAST LEN :[8]"</span>); 
<a name="l00445"></a>00445         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     uint32_t tmp_score = 0;
<a name="l00449"></a>00449     uint32_t score = 0;
<a name="l00450"></a>00450     memcpy(&amp;tmp_score, body+4, <span class="keyword">sizeof</span>(tmp_score));
<a name="l00451"></a>00451     score = ntohl(tmp_score);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count; ++i)
<a name="l00454"></a>00454     {
<a name="l00455"></a>00455         sprite_t* tmp_player = <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i];
<a name="l00456"></a>00456         <span class="keywordflow">if</span>(tmp_player-&gt;id == player-&gt;id)
<a name="l00457"></a>00457         {
<a name="l00458"></a>00458             tmp_player-&gt;score += score;
<a name="l00459"></a>00459             DEBUG_LOG(<span class="stringliteral">"TETRIS, USER [%d] SUBMIT SCORE, SUBMIT SCORE IS: [%d]."</span>, tmp_player-&gt;id, score); 
<a name="l00460"></a>00460         }
<a name="l00461"></a>00461     }
<a name="l00462"></a>00462     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00463"></a>00463 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6c4ec914098940b6d373a20d8203108c"></a><!-- doxytag: member="Tetris::handle_data" ref="6c4ec914098940b6d373a20d8203108c" args="(sprite_t *player, int cmd, const uint8_t body[], int body_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tetris::handle_data           </td>
          <td>(</td>
          <td class="paramtype">sprite_t *&nbsp;</td>
          <td class="paramname"> <em>player</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>body</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>body_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
提供给上层调用的三个接口函数之一。上层通知本模块处理相关事件的接口 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite_t*</em>&nbsp;</td><td>player, 玩家结构体指针 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>cmd, 通讯协议命令号 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>uint8_t body[], 消息包体指针 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>len, 消息包体的长度 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>int 类型错误码, -1踢掉发送此消息的用户；0正常继续游戏；其他参见结构体game_end_reason_t </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00081"></a>00081 { 
<a name="l00082"></a>00082 <span class="comment">//    DEBUG_LOG("%s: TETRIS HANDLE DATE", game_group_-&gt;game-&gt;name );</span>
<a name="l00083"></a>00083     MOD_EVENT_EXPIRE_TIME(player, on_timer_expire, get_now_tv()-&gt;tv_sec + 8);
<a name="l00084"></a>00084     <span class="keywordtype">int</span> err = -1;
<a name="l00085"></a>00085     <span class="keywordflow">switch</span> (cmd) {
<a name="l00086"></a>00086         <span class="keywordflow">case</span> proto_player_leave:
<a name="l00087"></a>00087             err = <a class="code" href="class_tetris.html#665ee31f1ead3dda47a0ed27ffa3861c" title="玩家离开了游戏，要清理本地资源">game_player_leave</a>(player, body, body_len);
<a name="l00088"></a>00088             <span class="keywordflow">break</span>;
<a name="l00089"></a>00089         <span class="keywordflow">case</span> <a class="code" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5bce668a76f25e2faa5f25b72751da31a" title="一个用户请求开始俄罗斯方块游戏">etetris_game_new_bout</a>:
<a name="l00090"></a>00090             err = <a class="code" href="class_tetris.html#99395dc5f1271c77236fc967687de13c" title="开始游戏, 当进入游戏的玩家满了后，通知所有人可以开始玩了...">tetris_new_bout</a>(player, body, body_len);
<a name="l00091"></a>00091             <span class="keywordflow">break</span>;
<a name="l00092"></a>00092         <span class="keywordflow">case</span> <a class="code" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5937bf10419f19636c7054b7dd7eeadd7" title="用户请求转发数据">etetris_trans_data</a>:
<a name="l00093"></a>00093             err = <a class="code" href="class_tetris.html#7562e7124f22612d3c482e8d1438d773" title="游戏过程中一个游戏用户提交了数据，要转发通知到其它各个用户...">tetris_trans_data</a>(player, body, body_len);
<a name="l00094"></a>00094             <span class="keywordflow">break</span>;
<a name="l00095"></a>00095         <span class="keywordflow">case</span> <a class="code" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae505f4df4aa6b266f26c6deaa92d3dc5e6" title="用户发送过来的俄罗斯方块游戏结束">etetris_game_end_bout</a>:
<a name="l00096"></a>00096             err = <a class="code" href="class_tetris.html#2eefabad6f82beb5a9f9d1173e40fccb" title="游戏结束了，记录用户提交上来的数据（输赢，分数）">tetris_end_bout</a>(player, body, body_len);
<a name="l00097"></a>00097             <span class="keywordflow">break</span>;
<a name="l00098"></a>00098         <span class="keywordflow">default</span>:
<a name="l00099"></a>00099             ERROR_RETURN((<span class="stringliteral">"%s: Unrecognized Command ID %d from uid=%u"</span>, 
<a name="l00100"></a>00100                           <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;name, cmd, player-&gt;id), -1);
<a name="l00101"></a>00101             <span class="keywordflow">break</span>;
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103     <span class="keywordflow">return</span> err;
<a name="l00104"></a>00104 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="36fa0cbee5475b1e3451e183dbf71388"></a><!-- doxytag: member="Tetris::handle_timeout" ref="36fa0cbee5475b1e3451e183dbf71388" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tetris::handle_timeout           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
处理用户游戏超时，处理方式，直接结束用户的游戏 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>void*</em>&nbsp;</td><td>data </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>枚举game_end_reason_t 类型值, 结束游戏码 </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00121"></a>00121 {
<a name="l00122"></a>00122     DEBUG_LOG(<span class="stringliteral">"%s: TETRIS HANDLE TIMEOUT"</span>, <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;name );
<a name="l00123"></a>00123     <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count &gt; 1)
<a name="l00124"></a>00124     {
<a name="l00125"></a>00125         <span class="comment">//find winner</span>
<a name="l00126"></a>00126         <span class="keywordtype">int</span> i = 0;
<a name="l00127"></a>00127         sprite_t* winner_player = <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[0];
<a name="l00128"></a>00128         <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count; ++i)
<a name="l00129"></a>00129         {
<a name="l00130"></a>00130             <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i]-&gt;score &gt; winner_player-&gt;score)
<a name="l00131"></a>00131             {
<a name="l00132"></a>00132                 winner_player = <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i];
<a name="l00133"></a>00133                 <a class="code" href="class_tetris.html#f3fb3cdef363f87fc48ca2f665f678b0" title="赢家的pos_id">winning_player_pos_</a> = winner_player-&gt;pos_id;
<a name="l00134"></a>00134             }
<a name="l00135"></a>00135         }
<a name="l00136"></a>00136         <span class="keywordflow">if</span>(!bhas_end_game) 
<a name="l00137"></a>00137         {
<a name="l00138"></a>00138             bhas_end_game = <span class="keyword">true</span>;
<a name="l00139"></a>00139             <a class="code" href="class_tetris.html#eb2ef9f36063b968d47fc2037d7be64f" title="游戏完毕，根据情形因子计算各类玩家获得的分数, 此处玩家分为赢家和输...">calculate_score</a>(<a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139720dae0984b1b909e1a900612939d82e0" title="超时，没有分出胜负">escore_timeout</a>);
<a name="l00140"></a>00140             notify_player_win(winner_player);
<a name="l00141"></a>00141             <a class="code" href="class_tetris.html#dabda5ae72fe3e51b6e7f31bd990a5f3" title="给用户分发分数">distribute_score</a>();
<a name="l00142"></a>00142         }
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144     <span class="keywordflow">else</span>
<a name="l00145"></a>00145     {
<a name="l00146"></a>00146         <a class="code" href="class_tetris.html#eb2ef9f36063b968d47fc2037d7be64f" title="游戏完毕，根据情形因子计算各类玩家获得的分数, 此处玩家分为赢家和输...">calculate_score</a>(<a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139720dae0984b1b909e1a900612939d82e0" title="超时，没有分出胜负">escore_timeout</a>);
<a name="l00147"></a>00147         notify_player_win(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[0]);
<a name="l00148"></a>00148         <a class="code" href="class_tetris.html#dabda5ae72fe3e51b6e7f31bd990a5f3" title="给用户分发分数">distribute_score</a>();
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150     <span class="keywordflow">return</span>  GER_end_of_game;
<a name="l00151"></a>00151 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="735b3d1ba1fc861c73804809fc8edcfd"></a><!-- doxytag: member="Tetris::init" ref="735b3d1ba1fc861c73804809fc8edcfd" args="(sprite_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tetris::init           </td>
          <td>(</td>
          <td class="paramtype">sprite_t *&nbsp;</td>
          <td class="paramname"> <em>player</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
提供给上层调用的三个接口函数之一. 以初始化游戏数据 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite_t*</em>&nbsp;</td><td>p, 玩家结构体指针 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00057"></a>00057 {
<a name="l00058"></a>00058     memset(<a class="code" href="class_tetris.html#3500653d2368ba3c3929af471366ac11" title="分数的种类, 目前两种：赢家，输家, 看客不给分数">game_score_</a>, 0, <span class="keyword">sizeof</span>(game_score_t)*2);
<a name="l00059"></a>00059     memset(<a class="code" href="class_tetris.html#25904f55bc4f8a3376302c06e494dfa7" title="记录游戏玩家每次的session号">game_sessions_</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="class_tetris.html#c66bb1be1bf916353982547a410efec1">suser_session</a>)*2);
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <a class="code" href="class_tetris.html#89728a478403846a2af3f73fa11460c7" title="判断玩家是否都准备好了可以接收转发数据">bready_to_transdata</a> = <span class="keyword">false</span>;
<a name="l00062"></a>00062     bhas_end_game = <span class="keyword">false</span>;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064     <a class="code" href="class_tetris.html#f3fb3cdef363f87fc48ca2f665f678b0" title="赢家的pos_id">winning_player_pos_</a> = 0;
<a name="l00065"></a>00065     uiplayer_ready_count = 0;
<a name="l00066"></a>00066     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count; ++i)
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068        <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i]-&gt;pos_id = i%2;
<a name="l00069"></a>00069     }
<a name="l00070"></a>00070 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8646c4e87b3836630a606ae90841aa62"></a><!-- doxytag: member="Tetris::notify_player_game_ready" ref="8646c4e87b3836630a606ae90841aa62" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tetris::notify_player_game_ready           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
通知加入本游戏的玩家，所有游戏成员都准备好了，可以开始游戏 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>void</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00370"></a>00370 {
<a name="l00371"></a>00371 <span class="comment">//    DEBUG_LOG("%s: notify client play game ready! user count %d, need count %d", </span>
<a name="l00372"></a>00372 <span class="comment">//                game_group_-&gt;game-&gt;name, game_group_-&gt;count, game_group_-&gt;game-&gt;players);</span>
<a name="l00373"></a>00373     <span class="keywordtype">int</span> i = <span class="keyword">sizeof</span>(protocol_t);
<a name="l00374"></a>00374     init_proto_head(pkg, <a class="code" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5bce668a76f25e2faa5f25b72751da31a" title="一个用户请求开始俄罗斯方块游戏">etetris_game_new_bout</a>, i);
<a name="l00375"></a>00375     send_to_players(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>, pkg, i);
<a name="l00376"></a>00376 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2eefabad6f82beb5a9f9d1173e40fccb"></a><!-- doxytag: member="Tetris::tetris_end_bout" ref="2eefabad6f82beb5a9f9d1173e40fccb" args="(sprite_t *player, const uint8_t body[], int body_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tetris::tetris_end_bout           </td>
          <td>(</td>
          <td class="paramtype">sprite_t *&nbsp;</td>
          <td class="paramname"> <em>player</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>body</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>body_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
游戏结束了，记录用户提交上来的数据（输赢，分数） 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite_t*</em>&nbsp;</td><td>player, 玩家结构体指针 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>uint8_t body[], 玩家发送来的数据体 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>body_len, 数据体长度 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>int类型 </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00285"></a>00285 {
<a name="l00286"></a>00286     assert(player != NULL);
<a name="l00287"></a>00287     assert(body != NULL);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="comment">//    DEBUG_LOG("tetris_end_bout(), player id:[%u], data body len = %d.", player-&gt;id, body_len);</span>
<a name="l00290"></a>00290 <span class="comment">//    DEBUG_LOG("this time player id:[%u], group user count:[%u].", player-&gt;id, game_group_-&gt;count);</span>
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     <span class="keywordflow">if</span>(!<a class="code" href="class_tetris.html#b9a2bfc4ad219d1e0788aace91f88fbd" title="检验用户此次的session号是否合法，并更新记录的session号，以用于下次检验...">check_player_session</a>(player, body, body_len)) <span class="keywordflow">return</span> -1;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294     <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count &gt; 1)
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count; ++i)
<a name="l00297"></a>00297         {
<a name="l00298"></a>00298             <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i]-&gt;id != player-&gt;id)
<a name="l00299"></a>00299             {
<a name="l00300"></a>00300                 <span class="keywordflow">if</span>(!bhas_end_game)
<a name="l00301"></a>00301                 {
<a name="l00302"></a>00302                     bhas_end_game = <span class="keyword">true</span>;
<a name="l00303"></a>00303                     <a class="code" href="class_tetris.html#eb2ef9f36063b968d47fc2037d7be64f" title="游戏完毕，根据情形因子计算各类玩家获得的分数, 此处玩家分为赢家和输...">calculate_score</a>(<a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c" title="正常玩完游戏，分出胜负">escore_normal</a>);
<a name="l00304"></a>00304                     <a class="code" href="class_tetris.html#f3fb3cdef363f87fc48ca2f665f678b0" title="赢家的pos_id">winning_player_pos_</a> = <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i]-&gt;pos_id;
<a name="l00305"></a>00305                     notify_player_win(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[i]);
<a name="l00306"></a>00306                     <a class="code" href="class_tetris.html#dabda5ae72fe3e51b6e7f31bd990a5f3" title="给用户分发分数">distribute_score</a>();
<a name="l00307"></a>00307                 }
<a name="l00308"></a>00308                 <span class="keywordflow">break</span>;
<a name="l00309"></a>00309             }
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312     <span class="keywordflow">else</span>
<a name="l00313"></a>00313     {
<a name="l00314"></a>00314         <a class="code" href="class_tetris.html#eb2ef9f36063b968d47fc2037d7be64f" title="游戏完毕，根据情形因子计算各类玩家获得的分数, 此处玩家分为赢家和输...">calculate_score</a>(<a class="code" href="class_tetris.html#435b20b884815365e545b6c6173b139714b4d385560da5c17beef33bd345810c" title="正常玩完游戏，分出胜负">escore_normal</a>);
<a name="l00315"></a>00315         notify_player_win(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;players[0]);
<a name="l00316"></a>00316         <a class="code" href="class_tetris.html#dabda5ae72fe3e51b6e7f31bd990a5f3" title="给用户分发分数">distribute_score</a>();
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318     <span class="keywordflow">return</span> GER_end_of_game;
<a name="l00319"></a>00319 } 
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="99395dc5f1271c77236fc967687de13c"></a><!-- doxytag: member="Tetris::tetris_new_bout" ref="99395dc5f1271c77236fc967687de13c" args="(sprite_t *plyaer, const uint8_t body[], int body_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tetris::tetris_new_bout           </td>
          <td>(</td>
          <td class="paramtype">sprite_t *&nbsp;</td>
          <td class="paramname"> <em>player</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>body</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>body_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
开始游戏, 当进入游戏的玩家满了后，通知所有人可以开始玩了 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite_t*</em>&nbsp;</td><td>player, 玩家结构体指针 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>uint8_t body[], 玩家发送来的数据体 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>body_len, 数据体长度 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00208"></a>00208 {
<a name="l00209"></a>00209     assert(player != NULL);
<a name="l00210"></a>00210     assert(body != NULL);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment">//    DEBUG_LOG("tetris_new_bout(), DATA BODY LEN :[%d].", body_len);</span>
<a name="l00213"></a>00213 <span class="comment">//    DEBUG_LOG("THIS TIME PLAYER ID:[%u], GROUP NEED USER COUNT:[%u].", player-&gt;id, game_group_-&gt;count);</span>
<a name="l00214"></a>00214     
<a name="l00215"></a>00215     <span class="keywordflow">if</span>(!<a class="code" href="class_tetris.html#b9a2bfc4ad219d1e0788aace91f88fbd" title="检验用户此次的session号是否合法，并更新记录的session号，以用于下次检验...">check_player_session</a>(player, body, body_len)) <span class="keywordflow">return</span> -1;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     uiplayer_ready_count++;
<a name="l00218"></a>00218     DEBUG_LOG(<span class="stringliteral">"ROUP HAS USER COUNT:[%u]."</span>, uiplayer_ready_count);
<a name="l00219"></a>00219     <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count == uiplayer_ready_count)
<a name="l00220"></a>00220     {
<a name="l00221"></a>00221         <a class="code" href="class_tetris.html#89728a478403846a2af3f73fa11460c7" title="判断玩家是否都准备好了可以接收转发数据">bready_to_transdata</a> = <span class="keyword">true</span>;;
<a name="l00222"></a>00222         <a class="code" href="class_tetris.html#8646c4e87b3836630a606ae90841aa62" title="通知加入本游戏的玩家，所有游戏成员都准备好了，可以开始游戏...">notify_player_game_ready</a>();
<a name="l00223"></a>00223         add_grp_timers(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>, get_now_tv()-&gt;tv_sec + 8);
<a name="l00224"></a>00224         ADD_TIMER_EVENT(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>, on_game_timer_expire, (<span class="keywordtype">void</span>*)1, get_now_tv()-&gt;tv_sec + <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;game-&gt;timeout -102);
<a name="l00225"></a>00225        <span class="comment">// DEBUG_LOG("ROUP HAS USER COUNT:[%u].", uiplayer_ready_count);</span>
<a name="l00226"></a>00226         <span class="keywordflow">return</span> 0;
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count &gt; uiplayer_ready_count)
<a name="l00229"></a>00229     {
<a name="l00230"></a>00230         <a class="code" href="class_tetris.html#89728a478403846a2af3f73fa11460c7" title="判断玩家是否都准备好了可以接收转发数据">bready_to_transdata</a> = <span class="keyword">false</span>;
<a name="l00231"></a>00231         <span class="keywordflow">return</span> 0;
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233     <span class="keywordflow">else</span><span class="comment">//(game_group_-&gt;count &lt; uiplayer_ready_count)</span>
<a name="l00234"></a>00234     {
<a name="l00235"></a>00235         uiplayer_ready_count--;
<a name="l00236"></a>00236         <span class="keywordflow">return</span> -1;
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238 } 
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7562e7124f22612d3c482e8d1438d773"></a><!-- doxytag: member="Tetris::tetris_trans_data" ref="7562e7124f22612d3c482e8d1438d773" args="(sprite_t *player, const uint8_t body[], int body_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tetris::tetris_trans_data           </td>
          <td>(</td>
          <td class="paramtype">sprite_t *&nbsp;</td>
          <td class="paramname"> <em>player</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>body</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>body_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
游戏过程中一个游戏用户提交了数据，要转发通知到其它各个用户 
<p>
<dl compact><dt><b>参数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite_t*</em>&nbsp;</td><td>player, 玩家结构体指针 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>uint8_t body[], 玩家发送来的数据体 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int</em>&nbsp;</td><td>body_len, 数据体长度 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>返回:</b></dt><dd>void </dd></dl>
<div class="fragment"><pre class="fragment"><a name="l00247"></a>00247 {
<a name="l00248"></a>00248     assert(player != NULL);
<a name="l00249"></a>00249     assert(body != NULL);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">//    DEBUG_LOG("tetris_trans_data(), PLAYER ID:[%u], DATA BODY LEN = %d.", player-&gt;id, body_len);</span>
<a name="l00252"></a>00252 <span class="comment">//    DEBUG_LOG("THIS TIME PLAYER ID:[%u], GROUP USER COUNT:[%u].", player-&gt;id, game_group_-&gt;count);</span>
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     <span class="keywordflow">if</span>(!<a class="code" href="class_tetris.html#b9a2bfc4ad219d1e0788aace91f88fbd" title="检验用户此次的session号是否合法，并更新记录的session号，以用于下次检验...">check_player_session</a>(player, body, body_len)) <span class="keywordflow">return</span> -1;
<a name="l00255"></a>00255     <span class="keywordflow">if</span>(!<a class="code" href="class_tetris.html#8d1b3c45f6d50a252bcac287acc46df2" title="解析玩家提交上来的游戏结果，分数">get_client_submit_result</a>(player, body, body_len)) <span class="keywordflow">return</span> -1;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="keywordflow">if</span>(IS_GAME_PLAYER(player)) 
<a name="l00258"></a>00258     {
<a name="l00259"></a>00259         <span class="keywordflow">if</span>(<a class="code" href="class_tetris.html#89728a478403846a2af3f73fa11460c7" title="判断玩家是否都准备好了可以接收转发数据">bready_to_transdata</a> &amp;&amp; <a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>-&gt;count &gt; 1)
<a name="l00260"></a>00260         {
<a name="l00261"></a>00261             <span class="keywordtype">int</span> i = <span class="keyword">sizeof</span>(protocol_t);
<a name="l00262"></a>00262             ant::pack(pkg, body+8, body_len-8, i); <span class="comment">//4字节uint32_t的session, 4字节uint32_t的score</span>
<a name="l00263"></a>00263             init_proto_head(pkg, <a class="code" href="class_tetris.html#5a35ce2e4e0573e2f78a24071131fae5937bf10419f19636c7054b7dd7eeadd7" title="用户请求转发数据">etetris_trans_data</a>, i);
<a name="l00264"></a>00264             send_to_group_except_self(<a class="code" href="class_tetris.html#9e362aa8bac35612cb28703f60b85043" title="构造函数参数中记录的游戏组指针">game_group_</a>, player-&gt;id, pkg, i);
<a name="l00265"></a>00265         }
<a name="l00266"></a>00266         <span class="keywordflow">else</span>
<a name="l00267"></a>00267         {
<a name="l00268"></a>00268         }
<a name="l00269"></a>00269         <span class="keywordflow">return</span> 0;
<a name="l00270"></a>00270     }
<a name="l00271"></a>00271     <span class="keywordflow">else</span>
<a name="l00272"></a>00272     {
<a name="l00273"></a>00273         <span class="keywordflow">return</span> -1;
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275 } 
</pre></div>
<p>

</div>
</div><p>
<hr>该类的文档由以下文件生成：<ul>
<li>E:/aw/my_svn/server/gameserv/games/tetris/<a class="el" href="tetris_8hpp.html">tetris.hpp</a><li>E:/aw/my_svn/server/gameserv/games/tetris/<a class="el" href="tetris_8cpp.html">tetris.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated at Thu Oct 30 10:37:13 2008 for Tetris by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
